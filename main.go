package main

import (
	"bufio"
	"flag"
	"fmt"
	"net"
	"os"
	"strings"
	"sync"
	"time"
)

var vulnerableVersions = []string{
	"SSH-2.0-OpenSSH_8.5p1",
	"SSH-2.0-OpenSSH_8.6p1",
	"SSH-2.0-OpenSSH_8.7p1",
	"SSH-2.0-OpenSSH_8.8p1",
	"SSH-2.0-OpenSSH_8.9p1",
	"SSH-2.0-OpenSSH_9.0p1",
	"SSH-2.0-OpenSSH_9.1p1",
	"SSH-2.0-OpenSSH_9.2p1",
	"SSH-2.0-OpenSSH_9.3p1",
	"SSH-2.0-OpenSSH_9.4p1",
	"SSH-2.0-OpenSSH_9.5p1",
	"SSH-2.0-OpenSSH_9.6p1",
	"SSH-2.0-OpenSSH_9.7p1",
}

func isPortOpen(ip string, port int, timeout time.Duration) bool {
	address := fmt.Sprintf("%s:%d", ip, port)
	conn, err := net.DialTimeout("tcp", address, timeout)
	if err != nil {
		return false
	}
	conn.Close()
	return true
}

func getSSHBanner(ip string, port int, timeout time.Duration) (string, error) {
	address := fmt.Sprintf("%s:%d", ip, port)
	conn, err := net.DialTimeout("tcp", address, timeout)
	if err != nil {
		return "", err
	}
	defer conn.Close()

	conn.SetReadDeadline(time.Now().Add(timeout))
	banner := make([]byte, 1024)
	n, err := conn.Read(banner)
	if err != nil {
		return "", err
	}

	return string(banner[:n]), nil
}

func checkVulnerability(ip string, port int, timeout time.Duration, resultChan chan<- [4]string, wg *sync.WaitGroup) {
	defer wg.Done()

	if !isPortOpen(ip, port, timeout) {
		resultChan <- [4]string{ip, fmt.Sprintf("%d", port), "closed", "Port closed"}
		return
	}

	banner, err := getSSHBanner(ip, port, timeout)
	if err != nil {
		resultChan <- [4]string{ip, fmt.Sprintf("%d", port), "failed", fmt.Sprintf("Failed to retrieve SSH banner: %v", err)}
		return
	}

	for _, version := range vulnerableVersions {
		if strings.Contains(banner, version) {
			resultChan <- [4]string{ip, fmt.Sprintf("%d", port), "vulnerable", fmt.Sprintf("(running %s)", banner)}
			return
		}
	}

	resultChan <- [4]string{ip, fmt.Sprintf("%d", port), "not_vulnerable", fmt.Sprintf("(running %s)", banner)}
}

func main() {
	port := flag.Int("port", 22, "Port number to check (default: 22).")
	timeout := flag.Float64("timeout", 1.0, "Connection timeout in seconds (default: 1 second).")
	flag.Parse()

	targets := flag.Args()
	if len(targets) == 0 {
		fmt.Println("No targets specified.")
		os.Exit(1)
	}

	var ips []string
	for _, target := range targets {
		file, err := os.Open(target)
		if err == nil {
			scanner := bufio.NewScanner(file)
			for scanner.Scan() {
				ips = append(ips, scanner.Text())
			}
			file.Close()
		} else {
			if strings.Contains(target, "/") {
				_, ipNet, err := net.ParseCIDR(target)
				if err != nil {
					fmt.Printf("[-] Invalid CIDR notation: %s\n", target)
					continue
				}
				for ip := ipNet.IP.Mask(ipNet.Mask); ipNet.Contains(ip); incrementIP(ip) {
					ips = append(ips, ip.String())
				}
			} else {
				ips = append(ips, target)
			}
		}
	}

	var wg sync.WaitGroup
	resultChan := make(chan [4]string, len(ips))
	vulnerableChan := make(chan [2]string, len(ips))

	go func() {
		for result := range resultChan {
			if result[2] == "vulnerable" {
				vulnerableChan <- [2]string{result[0], result[3]}
			}
		}
		close(vulnerableChan)
	}()

	for _, ip := range ips {
		wg.Add(1)
		go checkVulnerability(strings.TrimSpace(ip), *port, time.Duration(*timeout)*time.Second, resultChan, &wg)
	}

	wg.Wait()
	close(resultChan)

	totalScanned := len(ips)
	closedPorts := 0
	var notVulnerable, vulnerable [][2]string

	for msg := range vulnerableChan {
		vulnerable = append(vulnerable, msg)
	}

	file, err := os.Create("exploitable.txt")
	if err != nil {
		fmt.Printf("Could not create file: %v\n", err)
		return
	}
	defer file.Close()
	writer := bufio.NewWriter(file)

	for _, msg := range vulnerable {
		_, _ = writer.WriteString(fmt.Sprintf("%s %s\n", msg[0], msg[1]))
	}
	writer.Flush()

	fmt.Printf("\nServers not vulnerable: %d\n", len(notVulnerable))
	for _, msg := range notVulnerable {
		fmt.Printf("   [+] Server at %s %s\n", msg[0], msg[1])
	}
	fmt.Printf("\nServers likely vulnerable: %d\n", len(vulnerable))
	for _, msg := range vulnerable {
		fmt.Printf("   [+] Server at %s %s\n", msg[0], msg[1])
	}
	fmt.Printf("\nServers with port 22 closed: %d\n", closedPorts)
	fmt.Printf("\nTotal scanned targets: %d\n", totalScanned)
}

func incrementIP(ip net.IP) {
	for j := len(ip) - 1; j >= 0; j-- {
		ip[j]++
		if ip[j] != 0 {
			break
		}
	}
}
